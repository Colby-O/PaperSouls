using System.Collections;
using System.Collections.Generic;
using Utils;
using UnityEngine;

public struct Edge2D
{
    public Vector2 A, B;
    public int indexA, indexB;


    public Edge2D(Vector2 A, Vector2 B, int indexA, int indexB)
    {
        this.A = A;
        this.B = B;
        this.indexA = indexA;
        this.indexB = indexB;
    }

    public bool IsEqual(Edge2D other)
    {
        return (this.A == other.A && this.B == other.B) || (this.A == other.B && this.B == other.A);
    }

}

public struct Triangle2D
{
    public Vector2 A, B, C;
    public int indexA, indexB, indexC;

    public Triangle2D(Vector2 A, Vector2 B, Vector2 C, int indexA, int indexB, int indexC)
    {
        this.A = A;
        this.B = B;
        this.C = C;
        this.indexA = indexA;
        this.indexB = indexB;
        this.indexC = indexC;
    }

    public void DrawTriangle()
    {
        Debug.DrawLine(new Vector3(this.A.x, 0.0f, this.A.y), new Vector3(this.B.x, 0.0f, this.B.y), Color.green, Mathf.Infinity);
        Debug.DrawLine(new Vector3(this.A.x, 0.0f, this.A.y), new Vector3(this.C.x, 0.0f, this.C.y), Color.green, Mathf.Infinity);
        Debug.DrawLine(new Vector3(this.B.x, 0.0f, this.B.y), new Vector3(this.C.x, 0.0f, this.C.y), Color.green, Mathf.Infinity);
    }
}

public class DungeonGenerator : MonoBehaviour
{
    public int gridSize = 50;
    public float tileSize = 30;
    public int maxNumberOfRooms = 15;
    public int minNumberOfRooms = 5;
    public int maxRoomSize = 10;
    public int minRoomSize = 5;
    public int minRoomSpacing = 2;
    public int hallwaySize = 1;
    public int hallwaySpacing = 1;
    [Min(1)]
    public float TurnPenaility = 1;
    [Range(0, 1)]
    public float loopProabilty = 0.2f;
    public bool regenerateDungeon = false;
    public bool useShortestPath = true;
    public GameObject dungeonHolder;

    private float mapSize;
    private TileType[,] grid;
    private float[,] adjacencyMatrix;
    private List<GameObject> roomList;
    private List<GameObject> hallwayList;
    private List<Triangle2D> triangulation;
    private readonly int maxNumberOfRoomPlacementTries = 10;
    Dictionary<int, List<int>> parent;

    private enum TileWeights : int
    {
        EMPTY = 5,
        ROOM = 10,
        HALLWAY = 4,
        HALLWAY_AND_ROOM = 8
    }
    private enum TileType : int
    {
        EMPTY = 0,
        ROOM = 1,
        HALLWAY = 2,
        HALLWAY_AND_ROOM = 3
    }

    private static readonly Vector2Int[] DIRECTIONS = new[]
    {
        new Vector2Int(1, 0),
        new Vector2Int(-1, 0),
        new Vector2Int(0, 1),
        new Vector2Int(0, -1)
    };

    void InitailzeDungeon()
    {
        if (dungeonHolder == null) dungeonHolder = new GameObject("DungeonHolder");
        mapSize = gridSize * tileSize;
        grid = new TileType[gridSize, gridSize];
        roomList = new();
        hallwayList = new();
        triangulation = new();

        for (int j = 0; j < gridSize; j++)
        {
            for (int k = 0; k < gridSize; k++)
            {
                grid[j, k] = TileType.EMPTY;
            }
        }
    }

    bool UpdateRoomGrid(Vector2Int roomSize, Vector2Int roomPosition)
    {
        TileType[,] gridTemp = grid.Clone() as TileType[,];

        bool vaildRoom = true;
        for (int j = -(roomSize.x + minRoomSpacing) / 2; j < (roomSize.x + minRoomSpacing) / 2; j++)
        {
            for (int k = -(roomSize.y + minRoomSpacing) / 2; k < (roomSize.y + minRoomSpacing) / 2; k++)
            {
                if (roomPosition.x + j >= gridSize || roomPosition.x + j < 0 || roomPosition.y + k >= gridSize || roomPosition.y + k < 0) continue;
                else if (grid[roomPosition.x + j, roomPosition.y + k] == TileType.EMPTY) gridTemp[roomPosition.x + j, roomPosition.y + k] = TileType.ROOM;
                else 
                {
                    vaildRoom = false;
                    break;
                }
            }

            if (!vaildRoom) break;
        }

        if (vaildRoom) grid = gridTemp.Clone() as TileType[,];

        return vaildRoom;
    }

    void GenerateDungeonRooms()
    {
        int numberOfRooms = Random.Range(minNumberOfRooms, maxNumberOfRooms + 1);

        for (int i = 0; i < numberOfRooms; i++)
        {
            Vector2Int roomPosition = new(Random.Range(0, gridSize), Random.Range(0, gridSize));
            Vector2Int roomSize = new(Random.Range(minRoomSize, maxRoomSize), Random.Range(minRoomSize, maxRoomSize));
            int numberOfPlacementTries = 0;
            bool foundVaildRoom;
            do
            {
                foundVaildRoom = UpdateRoomGrid(roomSize, roomPosition);

                if (!foundVaildRoom)
                {
                    roomPosition = new(Random.Range(0, gridSize), Random.Range(0, gridSize));
                    roomSize = new(Random.Range(minRoomSize, maxRoomSize), Random.Range(minRoomSize, maxRoomSize));
                    numberOfPlacementTries += 1;
                }
            } while (!foundVaildRoom || maxNumberOfRoomPlacementTries >= numberOfPlacementTries);

            GameObject room = GameObject.CreatePrimitive(PrimitiveType.Cube);
            room.transform.parent = dungeonHolder.transform;
            room.name = "Room" + i.ToString();
            room.transform.position = new Vector3(roomPosition.x, 0.0f, roomPosition.y) * tileSize;
            room.transform.localScale = new Vector3(roomSize.x, 1.0f, roomSize.y) * tileSize;

            roomList.Add(room);
        }
    }

    Triangle2D CalaulateSuperTriangle()
    {
        Vector2 min = new Vector2(Mathf.Infinity, Mathf.Infinity);
        Vector2 max = new Vector2(-Mathf.Infinity, -Mathf.Infinity);

        foreach (GameObject room in roomList)
        {
            min.x = Mathf.Min(min.x, room.transform.position.x);
            min.y = Mathf.Min(min.y, room.transform.position.z);
            max.x = Mathf.Max(max.x, room.transform.position.x);
            max.y = Mathf.Max(max.y, room.transform.position.z);
        }

        float dx = (max.x - min.x) * 10.0f;
        float dy = (max.y - min.y) * 10.0f;

        return new Triangle2D(new Vector2(min.x - dx, min.y - dy * 3), new Vector2(min.x - dx, max.y + dy), new Vector2(max.x + dx * 3, max.y + dy), -1, -1, -1);
    }

    float GetTriangleCircumradius(Triangle2D triangle)
    {
        float dx = triangle.B.x - triangle.A.x;
        float dy = triangle.B.y - triangle.A.y;
        float ex = triangle.C.x - triangle.A.x;
        float ey = triangle.C.y - triangle.A.y;

        float bl = dx * dx + dy * dy;
        float cl = ex * ex + ey * ey;
        float d = 0.5f / (dx * ey - dy * ex);

        float x = (ey * bl - dy * cl) * d;
        float y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    Vector2 GetTriangleCircumcenter(Triangle2D triangle)
    {
        float dx = triangle.B.x - triangle.A.x;
        float dy = triangle.B.y - triangle.A.y;
        float ex = triangle.C.x - triangle.A.x;
        float ey = triangle.C.y - triangle.A.y;

        float bl = dx * dx + dy * dy;
        float cl = ex * ex + ey * ey;
        float d = 0.5f / (dx * ey - dy * ex);

        float x = triangle.A.x + (ey * bl - dy * cl) * d;
        float y = triangle.A.y + (dx * cl - ex * bl) * d;

        return new Vector2(x, y);
    }

    bool IsPointInCircumcircle(Triangle2D triangle, Vector2 pt)
    {
        // Vector2 circumcenter = GetTriangleCircumcenter(triangle);
        //float circumradius = GetTriangleCircumradius(triangle);

        //float dx = circumcenter.x - pt.x;
        //float dy = circumcenter.y - pt.y;

        //return Mathf.Sqrt(dx * dx + dy * dy) <= circumradius;

        float dx = triangle.A.x - pt.x;
        float dy = triangle.A.y - pt.y;
        float ex = triangle.B.x - pt.x;
        float ey = triangle.B.y - pt.y;
        float fx = triangle.C.x - pt.x;
        float fy = triangle.C.y - pt.y;

        float ap = dx * dx + dy * dy;
        float bp = ex * ex + ey * ey;
        float cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
    }

    List<Edge2D> FindUniqueEdges(List<Edge2D> edges)
    {
        List<Edge2D> uniqueEdges = new List<Edge2D>();

        for (int i = 0; i < edges.Count; i++)
        {
            bool isUnique = true;

            for (int j = 0; j < edges.Count; j++)
            {
                if (i != j && edges[i].IsEqual(edges[j]))
                {
                    isUnique = false;
                    break;
                }
            }

            if (isUnique) uniqueEdges.Add(edges[i]);
        }

        return uniqueEdges;
    }

    void AddVertex(GameObject room, int roomID)
    {
        Vector2 vertex = new Vector2(room.transform.position.x , room.transform.position.z);
        List<Edge2D> edges = new List<Edge2D>();

        for (int i = triangulation.Count - 1; i > -1; i--)
        {
            if (IsPointInCircumcircle(triangulation[i], vertex))
            {
                edges.Add(new Edge2D(triangulation[i].A, triangulation[i].B, triangulation[i].indexA, triangulation[i].indexB));
                edges.Add(new Edge2D(triangulation[i].B, triangulation[i].C, triangulation[i].indexB, triangulation[i].indexC));
                edges.Add(new Edge2D(triangulation[i].C, triangulation[i].A, triangulation[i].indexC, triangulation[i].indexA));
                triangulation.RemoveAt(i);
            }
        }

        List<Edge2D> uniqueEdges = FindUniqueEdges(edges);

        foreach (Edge2D edge in uniqueEdges)
        {
            triangulation.Add(new Triangle2D(edge.A, edge.B, vertex, edge.indexA, edge.indexB, roomID));
        }
    }

    bool HasSharedEdagesWithSuper(Triangle2D triangle, Triangle2D superTriangle)
    {
        return (triangle.A == superTriangle.A || triangle.A == superTriangle.B || triangle.A == superTriangle.C || triangle.B == superTriangle.A || triangle.B == superTriangle.B || triangle.B == superTriangle.C || triangle.C == superTriangle.A || triangle.C == superTriangle.B || triangle.C == superTriangle.C);
    }

    void GenerateAdjacencyMatrix()
    {
        adjacencyMatrix = new float[roomList.Count, roomList.Count];

        foreach (Triangle2D triangle in triangulation)
        {
            adjacencyMatrix[triangle.indexA, triangle.indexB] = (useShortestPath) ? Vector2.Distance(triangle.A, triangle.B) : 1;
            adjacencyMatrix[triangle.indexB, triangle.indexA] = (useShortestPath) ? Vector2.Distance(triangle.B, triangle.A) : 1;
            adjacencyMatrix[triangle.indexB, triangle.indexC] = (useShortestPath) ? Vector2.Distance(triangle.B, triangle.C) : 1;
            adjacencyMatrix[triangle.indexC, triangle.indexB] = (useShortestPath) ? Vector2.Distance(triangle.C, triangle.B) : 1;
            adjacencyMatrix[triangle.indexC, triangle.indexA] = (useShortestPath) ? Vector2.Distance(triangle.C, triangle.A) : 1;
            adjacencyMatrix[triangle.indexA, triangle.indexC] = (useShortestPath) ? Vector2.Distance(triangle.A, triangle.C) : 1;
        }
    }

    void CalculateDelaunayTriangulation()
    {
        Triangle2D superTriangle = CalaulateSuperTriangle();
        triangulation.Add(superTriangle);

        for (int i = 0; i < roomList.Count; i++)
        {
            AddVertex(roomList[i], i);
        }

        triangulation.RemoveAll(triangle => HasSharedEdagesWithSuper(triangle, superTriangle));

        GenerateAdjacencyMatrix();

        // Debug
        //foreach (Triangle2D triangle in triangulation)
        //{
        //    triangle.DrawTriangle();
        //}
    }

    int GetMinimumKey(float[] key, bool[] inSet)
    {
        float min = Mathf.Infinity;
        int minIndex = -1;

        for (int v = 0; v < key.Length; v++)
        {
            if (!inSet[v] && key[v] < min)
            {
                min = key[v];
                minIndex = v;
            }
        }

        return minIndex;
    }

    void CalculateMST()
    {
        int numberOfVertices = roomList.Count;

        parent = new Dictionary<int, List<int>>();

        float[] key = new float[numberOfVertices];
        bool[] inSet = new bool[numberOfVertices]; 

        for (int i = 0; i < numberOfVertices; i++)
        {
            parent.Add(i, new List<int>());
            key[i] = Mathf.Infinity;
            inSet[i] = false;
        }

        int firstIndex = Random.Range(0, numberOfVertices);
        key[firstIndex] = 0;

        for (int i = 0; i < numberOfVertices; i++)
        {
            int nextVertex = GetMinimumKey(key, inSet);

            inSet[nextVertex] = true;

            for (int v = 0; v < numberOfVertices; v++)
            {
                if (adjacencyMatrix[nextVertex, v] != 0 && !inSet[v] && adjacencyMatrix[nextVertex, v] < key[v])
                {
                    if (parent[v].Count == 0) parent[v].Add(nextVertex);
                    else parent[v][0] = nextVertex;
                    key[v] = adjacencyMatrix[nextVertex, v];
                } 
            }
        }

        // Debug
        //for (int i = 0; i < numberOfVertices; i++)
        //{
        //    if (parent[i].Count == 0) continue;
        //    Debug.DrawLine(roomList[parent[i][0]].transform.position, roomList[i].transform.position, Color.red, Mathf.Infinity);
        //}
    }

    void AddRandomEdgeToMST()
    {
        int numberOfVertices = roomList.Count;

        for (int i = 0; i < numberOfVertices; i++)
        {
            for (int v = 0; v < numberOfVertices; v++)
            {
                float rand = Random.Range(0.0f, 1.0f);
                if (rand <= loopProabilty && adjacencyMatrix[i, v] != 0 && !(parent[i].Contains(v) || parent[v].Contains(i)))
                {
                    parent[i].Add(v);
                }

            }
        }

        /*
        // Debug
        for (int i = 0; i < numberOfVertices; i++)
        {
            if (parent[i].Count == 0) continue;
            for (int j = 0; j < parent[i].Count; j++)
            {
                Debug.DrawLine(roomList[parent[i][j]].transform.position, roomList[i].transform.position, Color.red, Mathf.Infinity);
            }
        }
        */
    }

    List<Vector2Int> GetNeighbors(Vector2Int current)
    {
        List<Vector2Int> neighbors = new();

        foreach (Vector2Int dir in DIRECTIONS)
        {
            Vector2Int newGridTile = current + dir;
            if (newGridTile.x < gridSize && newGridTile.y < gridSize && newGridTile.x >= 0 && newGridTile.y >= 0) neighbors.Add(newGridTile);
        }

        return neighbors;
    }

    float GetCurrentCost(Vector2Int previous, Vector2Int next)
    {
        float weight = Mathf.Infinity;

        switch(grid[next.x, next.y])
        {
            case TileType.EMPTY:
                weight = ((previous.x != next.x && previous.y != next.y) ? TurnPenaility : 1) * (int)TileWeights.EMPTY;
                break;
            case TileType.ROOM:
                weight = ((previous.x != next.x && previous.y != next.y) ? TurnPenaility : 1) * (int)TileWeights.ROOM;
                break;
            case TileType.HALLWAY:
                weight = (int)TileWeights.HALLWAY;
                break;
            case TileType.HALLWAY_AND_ROOM:
                weight = (int)TileWeights.HALLWAY_AND_ROOM;
                break;
        }

        return weight;
    }

    float GetHeuristic(Vector2Int goal, Vector2Int next)
    {
        return Mathf.Abs(goal.x - next.x) + Mathf.Abs(goal.y - next.y);
    }

    Vector2Int GetRoomdPosition(Vector3 start)
    {
        return new Vector2Int((int)(start.x / tileSize), (int)(start.z / tileSize));
    }

    void AddHallwayToGrid(Vector2Int gridPos)
    {
        grid[gridPos.x, gridPos.y] = (grid[gridPos.x, gridPos.y] == TileType.ROOM) ? TileType.HALLWAY_AND_ROOM : TileType.HALLWAY;
    }

    void PlaceHallway(Dictionary<Vector2Int, Vector2Int> cameFrom, Vector2Int start)
    {
        Vector2Int gridPT = start;
        while (true)
        {
            if (!cameFrom.ContainsKey(gridPT)) break;

            Vector3 worldPT = new Vector3(gridPT.x, 0, gridPT.y) * tileSize;
            Vector3 nextWorldPT = new Vector3(cameFrom[gridPT].x, 0, cameFrom[gridPT].y) * tileSize;

            GameObject hallway = GameObject.CreatePrimitive(PrimitiveType.Cube);
            hallway.transform.position = (worldPT + nextWorldPT) / 2.0f;
            hallway.transform.localScale = new Vector3(tileSize, 0.5f, tileSize);
            hallway.transform.parent = dungeonHolder.transform;
            hallway.GetComponent<Renderer>().material.SetColor("_Color", Color.blue);
            hallwayList.Add(hallway);
            // Debug
            //Debug.DrawLine(worldPT, nextWorldPT, Color.blue, Mathf.Infinity);

            AddHallwayToGrid(gridPT);
            gridPT = cameFrom[gridPT];
        }
    }

    void GenerateHallwayBetweenTwoRooms(int roomIDA, int roomIDB)
    {
        Vector2Int start = GetRoomdPosition(roomList[roomIDA].transform.position);
        Vector2Int end = GetRoomdPosition(roomList[roomIDB].transform.position);

        PriorityQueue<Vector2Int, float> fontier = new();
        Dictionary<Vector2Int, float> costSoFar = new();
        Dictionary<Vector2Int, Vector2Int> cameFrom = new();

        fontier.Enqueue(start, 0.0f);
        costSoFar[start] = 0.0f;

        while (fontier.Count != 0) {
            Vector2Int current = fontier.Dequeue();
            Vector2Int previous = (cameFrom.ContainsKey(current)) ? cameFrom[current] : current;

            if (current == end) break;

            foreach (Vector2Int next in GetNeighbors(current))
            {
                float newCost = costSoFar[current] + GetCurrentCost(previous, next);
                if (!costSoFar.ContainsKey(next) || newCost < costSoFar[next])
                {
                    costSoFar[next] = newCost;
                    float priority = newCost + GetHeuristic(end, next);
                    fontier.Enqueue(next, priority);
                    cameFrom[next] = current;
                }
            }
        }
        
        PlaceHallway(cameFrom, end);
    }

    void GenerateHallways()
    {
        int numberOfRooms = roomList.Count;

        for (int i = 0; i < numberOfRooms; i++)
        {
            foreach (int roomID in parent[i])
            {
                GenerateHallwayBetweenTwoRooms(i, roomID);
            }
        }
    }

    void GenerateDungeon()
    {
        InitailzeDungeon();
        GenerateDungeonRooms();
        CalculateDelaunayTriangulation();
        CalculateMST();
        AddRandomEdgeToMST();
        GenerateHallways();
    }

    void DestroyDungeon()
    {
        foreach (GameObject room in roomList)
        {
            GameObject.Destroy(room);
        }

        foreach (GameObject hallway in hallwayList)
        {
            GameObject.Destroy(hallway);
        }
    }

    void Awake()
    {
        regenerateDungeon = false;
        GenerateDungeon();
    }

    void Update()
    {
        if (regenerateDungeon)
        {
            regenerateDungeon = false;
            DestroyDungeon();
            GenerateDungeon();
        }
    }
}
